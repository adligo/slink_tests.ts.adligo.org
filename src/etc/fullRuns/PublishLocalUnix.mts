/**
 * Copyright 2025 Adligo Inc / Scott Morgan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { I_AssertionContext } from '../../../../i_tests4ts.ts.adligo.org/src/i_tests4ts.mjs';
import { ApiTrial } from '../../../../tests4ts.ts.adligo.org/src/trials.mjs';
import { Test, TestParams } from '../../../../tests4ts.ts.adligo.org/src/tests4ts.mjs';
import { I_CliCtx, I_FsContext, SLinkRunner, Path, Paths } from '../../../../slink.ts.adligo.org/src/slink.mjs';
import { CliCtxMock, FsContextMock, CliCtxMockParams, FsContextMockParams, I_ExistsAbsResponse, I_ExistsResponse, I_ReadJsonResponse } from '../mocks/mocks.mjs';

export class PublishLocalUnix extends ApiTrial {
  public static testPublishLocalSuccess: Test = new Test(TestParams.of(
    'org.adligo.ts.slink_tests.PublishLocalUnix.' +
    'testPublishLocalSuccess').ignore(), (ac: I_AssertionContext) => {
      
    ac.isTrue(false, "TODO this code was generated by AI and needs auditing");
    // Setup
    const projectRoot: Path = Paths.newPath('/mock/current/project', false, false);
    const projectRootPackageJson: Path = Paths.newPath('/mock/current/project/package.json', false, false);
    const nodeModulesPath: Path = Paths.newPath('/mock/current/project/node_modules', false, false);
    const symlinkTarget: Path = Paths.newPath('/mock/shared/node_modules', false, false);
    const targetPackageDir: Path = Paths.newPath('/mock/shared/node_modules/@ts.adligo.org/slink', false, false);
    const binFilePath: Path = Paths.newPath('/mock/current/project/dist/slink.mjs', false, false);

    const cliCtxParams = new CliCtxMockParams();
    cliCtxParams._dir = projectRoot;
    cliCtxParams._windows = false;
    const mockCtx: CliCtxMock = new CliCtxMock(cliCtxParams);

    const fscParams = new FsContextMockParams();
    fscParams._ac = ac;
    fscParams._existsAbsResponses = [
      {_order: 1, _path: nodeModulesPath, _response: true },
      {_order: 2, _path: projectRootPackageJson, _response: true },
      {_order: 3, _path: targetPackageDir, _response: false }, // Package dir doesn't exist initially
      {_order: 4, _path: binFilePath, _response: true }
    ];

    const packageJson = JSON.stringify({
      name: '@ts.adligo.org/slink',
      version: '1.5.4',
      bin: {
        slink: './dist/slink.mjs'
      }
    });

    fscParams._readJsonResponses = [{ _path: projectRootPackageJson, _json: packageJson }];
    const mockFsc: FsContextMock = new FsContextMock(fscParams);

    // Mock isSymlink to return true
    mockFsc.isSymlink = (dir: Path): boolean => {
      if (dir.toString() === nodeModulesPath.toString()) {
        return true;
      }
      return false;
    };

    // Mock getSymlinkTarget to return the target path
    mockFsc.getSymlinkTarget = (dir: Path): Path => {
      if (dir.toString() === nodeModulesPath.toString()) {
        return symlinkTarget;
      }
      throw new Error('Unexpected symlink target request');
    };

    // Create SLinkRunner with mocks
    const runner = new SLinkRunner(mockCtx, mockFsc);
    runner.run();

    // Verify
    ac.equals(1, mockCtx.getDoneCalls(), "CliCtx.isDone() should be called once");
    ac.equals(1, mockCtx.getSetDirCalls(), "CliCtx.setDir() should be called once");
    // Additional verifications can be added based on expected behavior
  });

  public static testPublishLocalNoNodeModules: Test = new Test(TestParams.of(
    'org.adligo.ts.slink_tests.PublishLocalUnix.' +
    'testPublishLocalNoNodeModules').ignore(), (ac: I_AssertionContext) => {
      
    ac.isTrue(false, "TODO this code was generated by AI and needs auditing");
    // Setup
    const projectRoot: Path = Paths.newPath('/mock/current/project', false, false);
    const nodeModulesPath: Path = Paths.newPath('/mock/current/project/node_modules', false, false);

    const cliCtxParams = new CliCtxMockParams();
    cliCtxParams._dir = projectRoot;
    cliCtxParams._windows = false;
    const mockCtx: CliCtxMock = new CliCtxMock(cliCtxParams);

    const fscParams = new FsContextMockParams();
    fscParams._ac = ac;
    fscParams._existsAbsResponses = [
      {_order: 1, _path: nodeModulesPath, _response: false } // No node_modules
    ];

    const mockFsc: FsContextMock = new FsContextMock(fscParams);

    // Create SLinkRunner with mocks
    const runner = new SLinkRunner(mockCtx, mockFsc);

    // Should throw error
    let errorThrown = false;
    try {
      runner.run();
    } catch (error) {
      errorThrown = true;
      ac.isTrue(error.message.includes('No node_modules directory found'), 'Should throw appropriate error message');
    }
    ac.isTrue(errorThrown, 'Should throw error when no node_modules exists');
  });

  public static testPublishLocalNotSymlink: Test = new Test(TestParams.of(
    'org.adligo.ts.slink_tests.PublishLocalUnix.' +
    'testPublishLocalNotSymlink').ignore(), (ac: I_AssertionContext) => {
      
    ac.isTrue(false, "TODO this code was generated by AI and needs auditing");
    // Setup
    const projectRoot: Path = Paths.newPath('/mock/current/project', false, false);
    const nodeModulesPath: Path = Paths.newPath('/mock/current/project/node_modules', false, false);

    const cliCtxParams = new CliCtxMockParams();
    cliCtxParams._dir = projectRoot;
    cliCtxParams._windows = false;
    const mockCtx: CliCtxMock = new CliCtxMock(cliCtxParams);

    const fscParams = new FsContextMockParams();
    fscParams._ac = ac;
    fscParams._existsAbsResponses = [
      {_order: 1, _path: nodeModulesPath, _response: true }
    ];

    const mockFsc: FsContextMock = new FsContextMock(fscParams);

    // Mock isSymlink to return false
    mockFsc.isSymlink = (dir: Path): boolean => {
      return false;
    };

    // Create SLinkRunner with mocks
    const runner = new SLinkRunner(mockCtx, mockFsc);

    // Should throw error
    let errorThrown = false;
    try {
      runner.run();
    } catch (error) {
      errorThrown = true;
      ac.isTrue(error.message.includes('not a symlink'), 'Should throw appropriate error message');
    }
    ac.isTrue(errorThrown, 'Should throw error when node_modules is not a symlink');
  });

  public static testPublishLocalNoPackageJson: Test = new Test(TestParams.of(
    'org.adligo.ts.slink_tests.PublishLocalUnix.' +
    'testPublishLocalNoPackageJson').ignore(), (ac: I_AssertionContext) => {
    
    ac.isTrue(false, "TODO this code was generated by AI and needs auditing");
    // Setup
    const projectRoot: Path = Paths.newPath('/mock/current/project', false, false);
    const nodeModulesPath: Path = Paths.newPath('/mock/current/project/node_modules', false, false);
    const projectRootPackageJson: Path = Paths.newPath('/mock/current/project/package.json', false, false);
    const symlinkTarget: Path = Paths.newPath('/mock/shared/node_modules', false, false);

    const cliCtxParams = new CliCtxMockParams();
    cliCtxParams._dir = projectRoot;
    cliCtxParams._windows = false;
    const mockCtx: CliCtxMock = new CliCtxMock(cliCtxParams);

    const fscParams = new FsContextMockParams();
    fscParams._ac = ac;
    fscParams._existsAbsResponses = [
      {_order: 1, _path: nodeModulesPath, _response: true },
      {_order: 2, _path: projectRootPackageJson, _response: false } // No package.json
    ];

    const mockFsc: FsContextMock = new FsContextMock(fscParams);

    // Mock isSymlink to return true
    mockFsc.isSymlink = (dir: Path): boolean => {
      return true;
    };

    // Mock getSymlinkTarget to return the target path
    mockFsc.getSymlinkTarget = (dir: Path): Path => {
      return symlinkTarget;
    };

    // Create SLinkRunner with mocks
    const runner = new SLinkRunner(mockCtx, mockFsc);

    // Should throw error
    let errorThrown = false;
    try {
      runner.run();
    } catch (error) {
      errorThrown = true;
      ac.isTrue(error.message.includes('No package.json file found'), 'Should throw appropriate error message');
    }
    ac.isTrue(errorThrown, 'Should throw error when no package.json exists');
  });

  public static testPublishLocalWithExistingPackage: Test = new Test(TestParams.of(
    'org.adligo.ts.slink_tests.PublishLocalUnix.' +
    'testPublishLocalWithExistingPackage').ignore(), (ac: I_AssertionContext) => {
      
    ac.isTrue(false, "TODO this code was generated by AI and needs auditing");
    // Setup
    const projectRoot: Path = Paths.newPath('/mock/current/project', false, false);
    const projectRootPackageJson: Path = Paths.newPath('/mock/current/project/package.json', false, false);
    const nodeModulesPath: Path = Paths.newPath('/mock/current/project/node_modules', false, false);
    const symlinkTarget: Path = Paths.newPath('/mock/shared/node_modules', false, false);
    const targetPackageDir: Path = Paths.newPath('/mock/shared/node_modules/@ts.adligo.org/slink', false, false);

    const cliCtxParams = new CliCtxMockParams();
    cliCtxParams._dir = projectRoot;
    cliCtxParams._windows = false;
    const mockCtx: CliCtxMock = new CliCtxMock(cliCtxParams);

    const fscParams = new FsContextMockParams();
    fscParams._ac = ac;
    fscParams._existsAbsResponses = [
      {_order: 1, _path: nodeModulesPath, _response: true },
      {_order: 2, _path: projectRootPackageJson, _response: true },
      {_order: 3,_path: targetPackageDir, _response: true } // Package dir exists and should be removed
    ];

    const packageJson = JSON.stringify({
      name: '@ts.adligo.org/slink',
      version: '1.5.4'
    });

    fscParams._readJsonResponses = [{ _path: projectRootPackageJson, _json: packageJson }];
    const mockFsc: FsContextMock = new FsContextMock(fscParams);

    // Mock isSymlink to return true
    mockFsc.isSymlink = (dir: Path): boolean => {
      return true;
    };

    // Mock getSymlinkTarget to return the target path
    mockFsc.getSymlinkTarget = (dir: Path): Path => {
      return symlinkTarget;
    };

    // Create SLinkRunner with mocks
    const runner = new SLinkRunner(mockCtx, mockFsc);
    runner.run();

    // Verify
    ac.equals(1, mockCtx.getDoneCalls(), "CliCtx.isDone() should be called once");
    ac.equals(1, mockCtx.getSetDirCalls(), "CliCtx.setDir() should be called once");
    // Additional verifications for removal of existing package
  });

  constructor() {
    super('PublishLocalUnix', [
      PublishLocalUnix.testPublishLocalSuccess,
      PublishLocalUnix.testPublishLocalNoNodeModules,
      PublishLocalUnix.testPublishLocalNotSymlink,
      PublishLocalUnix.testPublishLocalNoPackageJson,
      PublishLocalUnix.testPublishLocalWithExistingPackage
    ]);
  }
}
